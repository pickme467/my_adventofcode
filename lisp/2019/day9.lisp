(defun input () (list
                 1102 34463338 34463338 63 1007 63 34463338 63 1005 63 53 1102
                 3 1 1000 109 988 209 12 9 1000 209 6 209
                 3 203 0 1008 1000 1 63 1005 63 65 1008 1000
                 2 63 1005 63 904 1008 1000 0 63 1005 63 58
                 4 25 104 0 99 4 0 104 0 99 4 17
                 104 0 99 0 0 1101 0 31 1019 1101 25 0
                 1008 1102 35 1 1009 1102 422 1 1029 1102 1 21
                 1005 1102 1 734 1027 1102 29 1 1000 1101 32 0
                 1018 1102 28 1 1016 1101 0 38 1015 1101 0 378
                 1023 1101 30 0 1017 1102 1 381 1022 1101 0 37
                 1006 1102 1 1 1021 1101 0 24 1011 1102 1 23
                 1002 1101 0 0 1020 1101 0 20 1007 1101 427 0
                 1028 1101 26 0 1014 1101 27 0 1010 1101 0 39
                 1001 1101 34 0 1012 1102 1 36 1013 1101 0 33
                 1003 1101 804 0 1025 1101 737 0 1026 1102 1 809
                 1024 1102 1 22 1004 109 9 1201 -7 0 63 1008
                 63 20 63 1005 63 205 1001 64 1 64 1106 0
                 207 4 187 1002 64 2 64 109 2 21102 40 1
                 1 1008 1012 40 63 1005 63 233 4 213 1001 64
                 1 64 1106 0 233 1002 64 2 64 109 4 1208
                 -7 25 63 1005 63 255 4 239 1001 64 1 64
                 1106 0 255 1002 64 2 64 109 -24 1207 10 38
                 63 1005 63 271 1105 1 277 4 261 1001 64 1
                 64 1002 64 2 64 109 25 21107 41 40 -3 1005
                 1013 293 1105 1 299 4 283 1001 64 1 64 1002
                 64 2 64 109 5 1205 -1 311 1106 0 317 4
                 305 1001 64 1 64 1002 64 2 64 109 -23 1202
                 6 1 63 1008 63 22 63 1005 63 339 4 323
                 1105 1 343 1001 64 1 64 1002 64 2 64 109
                 1 2101 0 2 63 1008 63 37 63 1005 63 367
                 1001 64 1 64 1106 0 369 4 349 1002 64 2
                 64 109 29 2105 1 -5 1106 0 387 4 375 1001
                 64 1 64 1002 64 2 64 109 -26 2101 0 0
                 63 1008 63 23 63 1005 63 409 4 393 1106 0
                 413 1001 64 1 64 1002 64 2 64 109 26 2106
                 0 0 4 419 1106 0 431 1001 64 1 64 1002
                 64 2 64 109 -17 21108 42 42 6 1005 1017 453
                 4 437 1001 64 1 64 1106 0 453 1002 64 2
                 64 109 7 21101 43 0 -8 1008 1010 44 63 1005
                 63 477 1001 64 1 64 1105 1 479 4 459 1002
                 64 2 64 109 -7 1206 10 495 1001 64 1 64
                 1106 0 497 4 485 1002 64 2 64 109 -5 2108
                 36 0 63 1005 63 513 1106 0 519 4 503 1001
                 64 1 64 1002 64 2 64 109 3 2102 1 -5
                 63 1008 63 22 63 1005 63 541 4 525 1105 1
                 545 1001 64 1 64 1002 64 2 64 109 3 1207
                 -6 38 63 1005 63 567 4 551 1001 64 1 64
                 1105 1 567 1002 64 2 64 109 -15 2107 20 8
                 63 1005 63 585 4 573 1106 0 589 1001 64 1
                 64 1002 64 2 64 109 -1 1208 5 36 63 1005
                 63 609 1001 64 1 64 1106 0 611 4 595 1002
                 64 2 64 109 30 21101 44 0 -7 1008 1019 44
                 63 1005 63 633 4 617 1106 0 637 1001 64 1
                 64 1002 64 2 64 109 -25 1201 0 0 63 1008
                 63 39 63 1005 63 659 4 643 1105 1 663 1001
                 64 1 64 1002 64 2 64 109 27 1206 -8 677
                 4 669 1106 0 681 1001 64 1 64 1002 64 2
                 64 109 -28 2108 29 0 63 1005 63 703 4 687
                 1001 64 1 64 1106 0 703 1002 64 2 64 109
                 5 21107 45 46 7 1005 1012 725 4 709 1001 64
                 1 64 1106 0 725 1002 64 2 64 109 30 2106
                 0 -8 1105 1 743 4 731 1001 64 1 64 1002
                 64 2 64 109 -22 21102 46 1 4 1008 1017 44
                 63 1005 63 767 1001 64 1 64 1105 1 769 4
                 749 1002 64 2 64 109 -15 1202 10 1 63 1008
                 63 23 63 1005 63 793 1001 64 1 64 1106 0
                 795 4 775 1002 64 2 64 109 19 2105 1 7
                 4 801 1105 1 813 1001 64 1 64 1002 64 2
                 64 109 6 1205 -2 827 4 819 1106 0 831 1001
                 64 1 64 1002 64 2 64 109 -20 2107 22 2
                 63 1005 63 851 1001 64 1 64 1106 0 853 4
                 837 1002 64 2 64 109 20 21108 47 44 -8 1005
                 1015 869 1105 1 875 4 859 1001 64 1 64 1002
                 64 2 64 109 -22 2102 1 4 63 1008 63 23
                 63 1005 63 899 1001 64 1 64 1106 0 901 4
                 881 4 64 99 21101 0 27 1 21102 915 1 0
                 1106 0 922 21201 1 28703 1 204 1 99 109 3
                 1207 -2 3 63 1005 63 964 21201 -2 -1 1 21101
                 0 942 0 1106 0 922 22101 0 1 -1 21201 -2
                 -3 1 21101 957 0 0 1105 1 922 22201 1 -1
                 -2 1105 1 968 21201 -2 0 -2 109 -3 2105 1 0))

(defparameter *debug* ())

(defun dbg (&rest params)
  (push (format nil (apply #'format nil params)) *debug*))

(defun sethash (key value hash)
  (setf (gethash key hash) value))

(defun copy-hash (source)
  (let ((new-hash (make-hash-table :test #'equal)))
    (maphash #'(lambda (key value) (sethash key value new-hash)) source)
    new-hash))

(defun get-value (pos-or-value mode relative program)
  (let ((value (cond
                 ((= 0 mode)
                  (if (> 0 pos-or-value)
                      (error "one")
                      (gethash pos-or-value program)))
                 ((= 2 mode)
                  (let ((address (+ relative pos-or-value)))
                    (if (> 0 address)
                        (error "two")
                        (gethash address  program))))
                 (t pos-or-value))))
    (if (null value) 0 value)))

(defun get-nth (index mode relative start program)
  (let ((x (gethash (+ start index) program)))
    (get-value x mode relative program)))

(defun do-three-argument (fn p1 p2 relative start program)
  (let ((x (get-nth 1 p1 relative start program))
        (y (get-nth 2 p2 relative start program))
        (pos (get-nth 3 1 relative start program)))
    (dbg "do-three-argument x: ~a, y: ~a, pos: ~a" x y pos)
    (let ((value (funcall fn x y)))
      (dbg "do-three-argument value: ~a" value)
      (setf (gethash pos program) value))))

(defun do-add (p1 p2 relative start program)
  (dbg "do-add p1: ~a, p2: ~a, relatieve: ~a, start: ~a" p1 p2 relative start)
  (do-three-argument #'+ p1 p2 relative start program))

(defun do-multiply (p1 p2 relative start program)
  (dbg "do-multiply p1: ~a, p2: ~a, relatieve: ~a, start: ~a" p1 p2 relative start)
  (do-three-argument #'* p1 p2 relative start program))

(defun do-input (input relative start program)
  (dbg "do-input input: ~a, relatieve: ~a, start: ~a" input relative start)
  (let* ((x (get-nth 1 1 relative start program))
         (address (gethash x program)))
    (dbg "do-input x: ~a, address: ~a" x address)
    (setf (gethash x program) input)))

(defun do-output (p1 relative start program)
  (dbg "do-output p1: ~a, relatieve: ~a, start: ~a" p1 relative start)
  (let ((value (get-nth 1 p1 relative start program)))
    (dbg "do-output value: ~a" value)
    value))

(defun do-jump-if-true (p1 p2 relative start program)
  (dbg "do-jump-if-true p1: ~a, p2: ~a, relatieve: ~a, start: ~a" p1 p2 relative start)
  (let ((x (get-nth 1 p1 relative start program)) (y (get-nth 2 p2 relative start program)))
    (dbg "do-jump-if-true x: ~a, y: ~a" x y)
    (if (/= 0 x)
        y
        (+ start 3))))

(defun do-jump-if-false (p1 p2 relative start program)
  (dbg "do-jump-if-false p1: ~a, p2: ~a, relatieve: ~a, start: ~a" p1 p2 relative start)
  (let ((x (get-nth 1 p1 relative start program)) (y (get-nth 2 p2 relative start program)))
    (dbg "do-jump-if-false x: ~a, y: ~a" x y)
    (if (= 0 x)
        y
        (+ start 3))))

(defun do-less-than (p1 p2 relative start program)
  (dbg "do-less-than p1: ~a, p2: ~a, relatieve: ~a, start: ~a" p1 p2 relative start)
  (let ((x (get-nth 1 p1 relative start program)) (y (get-nth 2 p2 relative start program)) (pos (get-nth 3 1 relative start program)))
    (dbg "do-less-than x: ~a, y: ~a, pos: ~a" x y pos)
    (if (< x y)
        (setf (gethash pos program) 1)
        (setf (gethash pos program) 0))))

(defun do-equals (p1 p2 relative start program)
  (dbg "do-equals p1: ~a, p2: ~a, relatieve: ~a, start: ~a" p1 p2 relative start)
  (let ((x (get-nth 1 p1 relative start program)) (y (get-nth 2 p2 relative start program)) (pos (get-nth 3 1 relative start program)))
    (dbg "do-equals x: ~a, y: ~a" x y)
    (if (= x y)
        (setf (gethash pos program) 1)
        (setf (gethash pos program) 0))))

(defun do-relative (p1 relative start program)
  (dbg "do-relative p1: ~a, relatieve: ~a, start: ~a" p1 relative start)
  (let ((value (get-nth 1 p1 relative start program)))
    (dbg "do-relative value: ~a" value)
    (+ relative value)))

(defun calculate (start program input output relative)
  (let ((command (gethash start program)))
    (multiple-value-bind (opcode p1 p2 p3) (decode-command command)
      (declare (ignore p3))
      (dbg "opcode: ~a, p1: ~a, p2: ~a" opcode p1 p2)
      (cond
        ((= opcode 99)
         (values output start program input output relative))
        ((= opcode 1)
         (do-add p1 p2 relative start program)
         (calculate (+ 4 start) program input output relative))
        ((= opcode 2)
         (do-multiply p1 p2 relative start program)
         (calculate (+ 4 start) program input output relative))
        ((= opcode 3)
         (do-input (pop input) relative start program)
         (calculate (+ 2 start) program input output relative))
        ((= opcode 4)
         (calculate (+ 2 start) program input (do-output p1 relative start program) relative))
        ((= opcode 5)
         (calculate (do-jump-if-true p1 p2 relative start program) program input output relative))
        ((= opcode 6)
         (calculate (do-jump-if-false p1 p2 relative start program) program input output relative))
        ((= opcode 7)
         (do-less-than p1 p2 relative start program)
         (calculate (+ 4 start) program input output relative))
        ((= opcode 8)
         (do-equals p1 p2 relative start program)
         (calculate (+ 4 start) program input output relative))
        ((= opcode 9)
         (calculate (+ 2 start) program input output (do-relative p1 relative start program)))
        (t output)))
      ))

(defun decode-command (command)
  (let* ((opcode (rem command 100))
         (p1 (rem (/ (- command opcode) 100) 10))
         (p2 (rem (/ (- command opcode (* 100 p1)) 1000) 10))
         (p3 (rem (/ (- command opcode (* 100 p1) (* 1000 p2)) 10000) 10)))
    (values opcode p1 p2 p3)))

(defun list-to-hash (list)
  (let ((address 0)
        (hash (make-hash-table :test #'equal)))
    (dolist (element list)
      (sethash address element hash)
      (incf address))
    hash))

(defun sample1 () (list 109 1 204 -1 1001 100 1 100 1008 100 16 101 1006 101 0 99))

(defun sample2 () (list 1102 34915192 34915192 7 4 7 99 0))

(defun sample3 () (list 104 1125899906842624 99))

(defun hash-to-list (hash)
  (let ((output ()))
    (maphash #'(lambda (key value) (push (list key value) output)) hash)
    (setf output (sort output #'< :key #'car))
    output))

;; verifications
(assert (= 99 (calculate 0 (list-to-hash (sample1)) 0 0 0)))
(assert (= 1219070632396864 (calculate 0 (list-to-hash (sample2)) 0 0 0)))
(assert (= 1125899906842624 (calculate 0 (list-to-hash (sample3)) 0 0 0)))

(assert (= 0 (calculate 0 (list-to-hash (input)) '(1) 0 0)))
