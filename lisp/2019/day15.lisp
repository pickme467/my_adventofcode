(defun input () (list
                 3 1033 1008 1033 1 1032 1005 1032 31 1008 1033 2 1032 1005 1032 58 1008
                 1033 3 1032 1005 1032 81 1008 1033 4 1032 1005 1032 104 99 102 1
                 1034 1039 1002 1036 1 1041 1001 1035 -1 1040 1008 1038 0 1043 102 -1
                 1043 1032 1 1037 1032 1042 1106 0 124 1002 1034 1 1039 102 1 1036
                 1041 1001 1035 1 1040 1008 1038 0 1043 1 1037 1038 1042 1105 1 124
                 1001 1034 -1 1039 1008 1036 0 1041 102 1 1035 1040 102 1 1038 1043
                 1002 1037 1 1042 1105 1 124 1001 1034 1 1039 1008 1036 0 1041 102
                 1 1035 1040 102 1 1038 1043 1002 1037 1 1042 1006 1039 217 1006 1040 217
                 1008 1039 40 1032 1005 1032 217 1008 1040 40 1032 1005 1032 217 1008 1039
                 33 1032 1006 1032 165 1008 1040 35 1032 1006 1032 165 1101 2 0 1044 1106
                 0 224 2 1041 1043 1032 1006 1032 179 1101 1 0 1044 1106 0 224 1
                 1041 1043 1032 1006 1032 217 1 1042 1043 1032 1001 1032 -1 1032 1002 1032
                 39 1032 1 1032 1039 1032 101 -1 1032 1032 101 252 1032 211 1007 0 37
                 1044 1105 1 224 1102 0 1 1044 1105 1 224 1006 1044 247 101 0
                 1039 1034 101 0 1040 1035 102 1 1041 1036 1001 1043 0 1038 1002 1042
                 1 1037 4 1044 1105 1 0 31 10 7 30 32 67 8 24 11 62
                 6 11 19 78 16 20 8 80 14 19 63 8 40 36 65 34 59
                 23 33 29 79 19 47 28 54 8 11 41 33 57 85 25 56 48
                 16 90 74 39 11 79 68 18 46 33 74 47 25 60 1 23 78
                 69 5 55 12 28 73 22 80 30 26 55 2 6 96 21 57 34
                 33 10 91 72 61 31 2 24 29 94 24 12 43 60 72 79 27
                 24 21 95 59 15 53 34 9 36 82 83 4 67 30 62 5 70
                 94 1 81 75 6 18 68 9 26 38 31 1 98 57 97 63 8
                 60 35 5 48 36 59 75 4 88 23 21 39 10 99 13 36 53
                 66 73 28 33 80 28 78 23 7 30 27 77 28 69 69 1 65
                 78 17 17 2 16 27 91 43 27 72 93 6 5 92 12 55 79
                 94 98 60 19 15 36 35 55 9 62 84 27 74 56 25 9 60
                 72 15 34 59 15 31 58 76 24 81 62 99 35 31 14 39 25
                 60 3 5 46 24 48 22 1 73 99 96 27 46 48 5 65 26
                 6 48 11 13 69 12 33 22 95 11 72 28 42 28 88 5 31
                 56 50 72 30 49 84 52 32 11 45 7 54 60 12 72 33 38
                 62 18 54 31 8 92 53 34 4 76 21 46 81 53 81 21 10
                 63 12 75 22 62 87 32 23 30 40 29 24 61 6 88 70 14
                 18 99 13 14 4 72 5 22 54 90 75 35 1 10 49 17 7
                 98 8 81 13 47 59 13 80 70 9 26 73 22 77 3 22 73
                 99 74 11 10 60 4 27 86 46 67 30 94 29 93 26 66 25
                 8 14 92 24 45 78 24 23 97 31 9 25 25 61 44 35 31
                 73 52 80 35 96 32 43 8 66 57 87 31 85 12 50 74 7
                 23 61 12 7 78 1 1 53 14 54 18 18 63 41 25 90 1
                 85 24 22 98 62 35 14 19 50 80 20 7 73 21 14 81 19
                 89 11 31 84 7 53 9 54 20 90 72 31 70 54 17 31 59
                 18 8 69 83 58 78 12 98 20 81 26 50 95 19 25 54 31
                 80 67 6 3 87 6 99 93 22 75 73 34 52 58 22 32 52
                 34 30 85 54 58 75 14 22 97 12 36 53 67 32 99 54 15
                 4 66 69 7 48 87 25 17 41 57 10 63 35 24 43 5 57
                 25 93 22 71 7 36 63 84 26 4 7 78 26 68 77 35 9
                 70 17 12 59 41 78 18 54 18 80 18 86 93 19 35 73 34
                 53 97 23 2 95 30 32 85 21 21 79 19 18 85 57 23 85
                 35 34 61 30 66 29 19 76 30 17 46 1 16 98 26 25 91
                 15 47 54 75 26 17 36 74 60 33 28 49 53 15 13 45 6
                 90 26 73 17 87 4 68 18 30 22 96 92 97 14 40 24 50
                 96 15 49 55 79 8 16 1 50 5 60 55 14 41 67 25 26
                 71 18 26 89 70 14 6 51 11 94 68 69 22 73 63 6 33
                 88 36 51 20 6 44 26 71 17 31 11 86 81 23 31 80 18
                 87 26 12 91 8 41 6 18 9 33 90 1 59 56 32 29 54
                 50 34 12 74 97 10 39 87 41 9 52 67 21 22 38 61 57
                 1 87 4 35 98 61 16 95 78 65 17 31 9 71 9 52 52
                 9 8 73 40 36 16 48 52 9 26 39 4 17 42 1 35 80 93
                 4 40 23 13 66 7 28 84 73 22 31 76 31 21 39 4 83
                 84 41 27 66 34 88 15 50 65 45 22 65 26 78 15 50 40
                 79 31 38 9 60 2 51 24 46 99 42 27 45 1 71 20 78
                 86 95 9 81 0 0 21 21 1 10 1 0 0 0 0 0 0))

(defun newhash ()
  (make-hash-table :test #'equal))

(defun sethash (key value hash)
  (setf (gethash key hash) value))

(defun copyhash (hash)
  (let ((new (newhash)))
    (maphash #'(lambda (k v)
                 (sethash k v new)) hash)
    new))

(defun get-value (pos-or-value mode relative program)
  (let ((value
         (cond
           ((= 0 mode)
            (if (> 0 pos-or-value)
                (error "negative pointer not allowed in positional mode")
                (gethash pos-or-value program)))
           ((= 2 mode)
            (let ((address (+ relative pos-or-value)))
              (if (> 0 address)
                  (error "negative pointer not allowed in relative mode")
                  (gethash address  program))))
           (t pos-or-value))))
    (if (null value) 0 value)))

(defun get-at-index (index start program)
  (gethash (+ start index) program))

(defun get-nth (index mode relative start program)
  (get-value (get-at-index index start program) mode relative program))

(defun get-nth-write (index mode relative start program)
  (let ((pos (get-at-index index start program)))
    (cond
      ((= 0 mode) pos)
      ((= 2 mode) (+ pos relative))
      (t (error "mode not allowed for write parameter")))))

(defun do-three-argument (fn p1 p2 p3 relative start program)
  (let ((x (get-nth 1 p1 relative start program))
        (y (get-nth 2 p2 relative start program))
        (pos (get-nth-write 3 p3 relative start program)))
    (let ((value (funcall fn x y)))
      (sethash pos value program))))

(defun do-add (p1 p2 p3 relative start program)
  (do-three-argument #'+ p1 p2 p3 relative start program))

(defun do-multiply (p1 p2 p3 relative start program)
  (do-three-argument #'* p1 p2 p3 relative start program))

(defun do-input (input mode relative start program)
  (let ((x (get-nth-write 1 mode relative start program)))
    (if (null input) (error "nil input"))
    (sethash x input program)))

(defun do-output (p1 relative start program)
  (let ((value (get-nth 1 p1 relative start program)))
    value))

(defun do-jump-if-true (p1 p2 relative start program)
  (let ((x (get-nth 1 p1 relative start program)) (y (get-nth 2 p2 relative start program)))
    (if (/= 0 x)
        y
        (+ start 3))))

(defun do-jump-if-false (p1 p2 relative start program)
  (let ((x (get-nth 1 p1 relative start program)) (y (get-nth 2 p2 relative start program)))
    (if (= 0 x)
        y
        (+ start 3))))

(defun do-less-than (p1 p2 p3 relative start program)
  (let ((x (get-nth 1 p1 relative start program))
        (y (get-nth 2 p2 relative start program))
        (pos (get-nth-write 3 p3 relative start program)))
    (if (< x y)
        (sethash pos 1 program)
        (sethash pos 0 program))))

(defun do-equals (p1 p2 p3 relative start program)
  (let ((x (get-nth 1 p1 relative start program))
        (y (get-nth 2 p2 relative start program))
        (pos (get-nth-write 3 p3 relative start program)))
    (if (= x y)
        (sethash pos 1 program)
        (sethash pos 0 program))))

(defun do-relative (p1 relative start program)
  (let ((value (get-nth 1 p1 relative start program)))
    (+ relative value)))

(defun calculate (input start program relative output)
  (let ((command (gethash start program)))
    (multiple-value-bind (opcode p1 p2 p3) (decode-command command)
      (cond
        ((= opcode 99)
         (values 'done (list output start program relative)))
        ((= opcode 1)
         (do-add p1 p2 p3 relative start program)
         (calculate input (+ 4 start) program relative output))
        ((= opcode 2)
         (do-multiply p1 p2 p3 relative start program)
         (calculate input (+ 4 start) program relative output))
        ((= opcode 3)
         (if (null input)
             (values 'input (list output start program relative output))
             (progn
               (do-input (pop input) p1 relative start program)
               (calculate input (+ 2 start) program relative output))))
        ((= opcode 4)
         (let ((new-output (push (do-output p1 relative start program) output)))
           (calculate input (+ 2 start) program relative new-output)))
        ((= opcode 5)
         (calculate input (do-jump-if-true p1 p2 relative start program) program relative output))
        ((= opcode 6)
         (calculate input (do-jump-if-false p1 p2 relative start program) program relative output))
        ((= opcode 7)
         (do-less-than p1 p2 p3 relative start program)
         (calculate input (+ 4 start) program relative output))
        ((= opcode 8)
         (do-equals p1 p2 p3 relative start program)
         (calculate input (+ 4 start) program relative output))
        ((= opcode 9)
         (calculate input (+ 2 start) program (do-relative p1 relative start program) output))
        (t output)))))

(defun decode-command (command)
  (let* ((opcode (rem command 100))
         (p1 (rem (/ (- command opcode) 100) 10))
         (p2 (rem (/ (- command opcode (* 100 p1)) 1000) 10))
         (p3 (rem (/ (- command opcode (* 100 p1) (* 1000 p2)) 10000) 10)))
    (values opcode p1 p2 p3)))

(defun list-to-hash (list)
  (let ((address 0)
        (hash (newhash)))
    (dolist (element list)
      (sethash address element hash)
      (incf address))
    hash))

(defun find-oxygen (input)
  (let ((found-hash (newhash))
        (map (newhash))
        (context (list 0 (list-to-hash input) 0 ())))
    (dotimes (n 4)
      (recursive (1+ n) context 0 0 map input found-hash))
    (let ((found (gethash 'found found-hash)))
      (values (length (nth 0 found)) (nth 1 found) (nth 2 found) map))))

(defun recursive (direction context old-x old-y map list found)
  (cond ((> (hash-table-count found) 0) nil)
        (t
         (multiple-value-bind (type result)
             (apply #'calculate (list direction) context)
           (declare (ignore type))
           (let ((output (get-output-from-result result))
                 (x (+ old-x (x-delta direction)))
                 (y (+ old-y (y-delta direction))))
             (cond
               ((= 2 (car output))
                (sethash 'found (list output x y) found)
                context)
               ((or (= 0 (car output))(visitedp x y map))
                nil)
               (t
                (fill-empty x y map)
                (dotimes (n 4)
                  (let ((context-copy (make-context-from-result result)))
                    (recursive (1+ n) context-copy x y map list found))))))))))

(defun get-output-from-result (result)
  (nth 0 result))

(defun make-context-from-result (result)
  (let ((start (nth 1 result))
        (hash (nth 2 result))
        (relative (nth 3 result))
        (output (nth 4 result)))
    (list start (copyhash hash) relative output)))

(defun visitedp (x y map)
  (not (null (gethash (list x y) map))))

(defun x-delta (direction)
  (let ((delta (- (rem (* 2 (- direction 2)) 5) 3)))
    (if (or (> delta 1) (< delta -1)) 0 delta)))

(defun y-delta (direction)
  (let ((delta (- (rem (* 2 direction) 5) 3)))
    (if (or (> delta 1) (< delta -1)) 0 delta)))

(defun bubble-with-oxygen (input)
  (multiple-value-bind (length x y  map) (find-oxygen input)
    (declare (ignore length))
    (fill-empty x y map)
    (put-oxygen x y map)
    (do
     ((count 0 (1+ count)))
     ((all-filledp map) count)
      (put-oxygen-to-neighbours map))))

(defun put-oxygen-to-neighbours (map)
  (let ((to-put ()))
    (maphash #'(lambda (pos status)
                 (let ((x (nth 0 pos))
                       (y (nth 1 pos)))
                   (cond
                     ((equal status 'filled) t)
                     ((or
                       (filledp (1- x) y map)
                       (filledp (1+ x) y map)
                       (filledp x (1+ y) map)
                       (filledp x (1- y) map))
                      (setf to-put (push pos to-put)))))) map)
    (dolist (point to-put)
      (put-oxygen (nth 0 point) (nth 1 point) map))))

(defun put-oxygen (x y map)
  (cond
    ((not (on-map-p x y map))nil)
    (t
     (sethash (list x y) 'filled map))))

(defun fill-empty (x y map)
  (sethash (list x y) 'empty map))

(defun on-map-p (x y map)
  (not (null (gethash (list x y) map))))

(defun filledp (x y map)
  (equal 'filled (gethash (list x y) map)))

(defun filled-or-not-on-map (x y map)
  (or (on-map-p x y map) (filledp x y map)))

(defun finished-filling (status)
  (> (hash-table-count status) 0))

(defun all-filledp (map)
  (let ((filled t))
    (maphash #'(lambda (k v)
                 (declare (ignore k))
                 (if (equal v 'empty)
                     (setf filled nil))) map)
    filled))

;; day 15 part 1
(time (assert (= 222 (find-oxygen (input)))))

;; day 15 part 2
(time (assert (= 394 (bubble-with-oxygen (input)))))
