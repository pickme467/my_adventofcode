(defun input ()
  '(1 330 331 332 109 3544 1101 0 1182 15 1102 1453 1 24 1002 0 1 570 1006 570 36 1001 571 0 0 1001 570 -1 570 1001 24 1 24 1106 0 18 1008 571 0 571 1001 15 1 15 1008 15 1453 570 1006 570 14 21101 58 0 0 1106 0 786 1006 332 62 99 21101 0 333 1 21101 0 73 0 1105 1 579 1102 1 0 572 1101 0 0 573 3 574 101 1 573 573 1007 574 65 570 1005 570 151 107 67 574 570 1005 570 151 1001 574 -64 574 1002 574 -1 574 1001 572 1 572 1007 572 11 570 1006 570 165 101 1182 572 127 102 1 574 0 3 574 101 1 573 573 1008 574 10 570 1005 570 189 1008 574 44 570 1006 570 158 1105 1 81 21101 0 340 1 1105 1 177 21101 0 477 1 1106 0 177 21101 514 0 1 21102 176 1 0 1105 1 579 99 21101 184 0 0 1105 1 579 4 574 104 10 99 1007 573 22 570 1006 570 165 1002 572 1 1182 21101 375 0 1 21102 1 211 0 1106 0 579 21101 1182 11 1 21102 1 222 0 1106 0 979 21102 388 1 1 21101 233 0 0 1105 1 579 21101 1182 22 1 21101 244 0 0 1106 0 979 21102 1 401 1 21101 0 255 0 1105 1 579 21101 1182 33 1 21102 1 266 0 1105 1 979 21102 414 1 1 21102 1 277 0 1106 0 579 3 575 1008 575 89 570 1008 575 121 575 1 575 570 575 3 574 1008 574 10 570 1006 570 291 104 10 21102 1 1182 1 21101 0 313 0 1105 1 622 1005 575 327 1102 1 1 575 21101 0 327 0 1105 1 786 4 438 99 0 1 1 6 77 97 105 110 58 10 33 10 69 120 112 101 99 116 101 100 32 102 117 110 99 116 105 111 110 32 110 97 109 101 32 98 117 116 32 103 111 116 58 32 0 12 70 117 110 99 116 105 111 110 32 65 58 10 12 70 117 110 99 116 105 111 110 32 66 58 10 12 70 117 110 99 116 105 111 110 32 67 58 10 23 67 111 110 116 105 110 117 111 117 115 32 118 105 100 101 111 32 102 101 101 100 63 10 0 37 10 69 120 112 101 99 116 101 100 32 82 44 32 76 44 32 111 114 32 100 105 115 116 97 110 99 101 32 98 117 116 32 103 111 116 58 32 36 10 69 120 112 101 99 116 101 100 32 99 111 109 109 97 32 111 114 32 110 101 119 108 105 110 101 32 98 117 116 32 103 111 116 58 32 43 10 68 101 102 105 110 105 116 105 111 110 115 32 109 97 121 32 98 101 32 97 116 32 109 111 115 116 32 50 48 32 99 104 97 114 97 99 116 101 114 115 33 10 94 62 118 60 0 1 0 -1 -1 0 1 0 0 0 0 0 0 1 26 40 0 109 4 2101 0 -3 586 21002 0 1 -1 22101 1 -3 -3 21101 0 0 -2 2208 -2 -1 570 1005 570 617 2201 -3 -2 609 4 0 21201 -2 1 -2 1105 1 597 109 -4 2106 0 0 109 5 1201 -4 0 630 20102 1 0 -2 22101 1 -4 -4 21101 0 0 -3 2208 -3 -2 570 1005 570 781 2201 -4 -3 652 21001 0 0 -1 1208 -1 -4 570 1005 570 709 1208 -1 -5 570 1005 570 734 1207 -1 0 570 1005 570 759 1206 -1 774 1001 578 562 684 1 0 576 576 1001 578 566 692 1 0 577 577 21101 702 0 0 1105 1 786 21201 -1 -1 -1 1105 1 676 1001 578 1 578 1008 578 4 570 1006 570 724 1001 578 -4 578 21102 1 731 0 1105 1 786 1105 1 774 1001 578 -1 578 1008 578 -1 570 1006 570 749 1001 578 4 578 21102 1 756 0 1105 1 786 1105 1 774 21202 -1 -11 1 22101 1182 1 1 21101 774 0 0 1105 1 622 21201 -3 1 -3 1106 0 640 109 -5 2106 0 0 109 7 1005 575 802 20101 0 576 -6 20102 1 577 -5 1106 0 814 21101 0 0 -1 21102 0 1 -5 21102 1 0 -6 20208 -6 576 -2 208 -5 577 570 22002 570 -2 -2 21202 -5 51 -3 22201 -6 -3 -3 22101 1453 -3 -3 1202 -3 1 843 1005 0 863 21202 -2 42 -4 22101 46 -4 -4 1206 -2 924 21102 1 1 -1 1106 0 924 1205 -2 873 21101 35 0 -4 1106 0 924 2102 1 -3 878 1008 0 1 570 1006 570 916 1001 374 1 374 2102 1 -3 895 1102 2 1 0 1201 -3 0 902 1001 438 0 438 2202 -6 -5 570 1 570 374 570 1 570 438 438 1001 578 558 921 21002 0 1 -4 1006 575 959 204 -4 22101 1 -6 -6 1208 -6 51 570 1006 570 814 104 10 22101 1 -5 -5 1208 -5 41 570 1006 570 810 104 10 1206 -1 974 99 1206 -1 974 1102 1 1 575 21101 0 973 0 1105 1 786 99 109 -7 2105 1 0 109 6 21102 1 0 -4 21102 0 1 -3 203 -2 22101 1 -3 -3 21208 -2 82 -1 1205 -1 1030 21208 -2 76 -1 1205 -1 1037 21207 -2 48 -1 1205 -1 1124 22107 57 -2 -1 1205 -1 1124 21201 -2 -48 -2 1105 1 1041 21101 0 -4 -2 1105 1 1041 21102 -5 1 -2 21201 -4 1 -4 21207 -4 11 -1 1206 -1 1138 2201 -5 -4 1059 1202 -2 1 0 203 -2 22101 1 -3 -3 21207 -2 48 -1 1205 -1 1107 22107 57 -2 -1 1205 -1 1107 21201 -2 -48 -2 2201 -5 -4 1090 20102 10 0 -1 22201 -2 -1 -2 2201 -5 -4 1103 1201 -2 0 0 1106 0 1060 21208 -2 10 -1 1205 -1 1162 21208 -2 44 -1 1206 -1 1131 1105 1 989 21102 439 1 1 1105 1 1150 21101 477 0 1 1106 0 1150 21102 1 514 1 21101 0 1149 0 1106 0 579 99 21102 1157 1 0 1105 1 579 204 -2 104 10 99 21207 -3 22 -1 1206 -1 1138 2101 0 -5 1176 2101 0 -4 0 109 -6 2106 0 0 26 9 42 1 7 1 42 1 7 1 42 1 7 1 38 9 3 1 38 1 3 1 3 1 3 1 38 1 3 1 3 1 3 1 38 1 3 1 3 1 3 1 38 1 1 11 38 1 1 1 1 1 3 1 36 5 1 1 1 1 1 5 36 1 3 1 1 1 1 1 42 1 3 1 1 9 36 1 3 1 3 1 5 1 36 1 3 1 3 1 5 1 36 1 3 1 3 1 5 1 36 9 5 1 40 1 9 1 40 1 9 1 3 7 30 1 9 1 3 1 5 1 10 9 1 11 9 1 3 1 5 1 10 1 7 1 1 1 19 1 3 1 5 1 10 1 7 1 1 1 19 11 10 1 7 1 1 1 23 1 16 1 7 1 1 1 23 1 3 9 4 1 7 1 1 1 23 1 11 1 4 1 7 1 1 1 23 9 3 1 4 1 7 1 1 1 31 1 3 1 4 11 29 11 8 1 31 1 1 1 3 1 3 1 8 11 21 1 1 1 3 1 3 1 18 1 21 1 1 1 3 1 3 1 18 1 21 7 3 1 18 1 23 1 7 1 18 1 23 1 7 1 18 1 23 1 7 1 18 1 23 9 18 1 50 1 50 1 50 9 24))

(defun newhash ()
  (make-hash-table :test #'equal))

(defun sethash (key value hash)
  (setf (gethash key hash) value))

(defun copyhash (hash)
  (let ((new (newhash)))
    (maphash #'(lambda (k v)
                 (sethash k v new)) hash)
    new))

(defun get-value (pos-or-value mode relative program)
  (let ((value
         (cond
           ((= 0 mode)
            (if (> 0 pos-or-value)
                (error "negative pointer not allowed in positional mode")
                (gethash pos-or-value program)))
           ((= 2 mode)
            (let ((address (+ relative pos-or-value)))
              (if (> 0 address)
                  (error "negative pointer not allowed in relative mode")
                  (gethash address  program))))
           (t pos-or-value))))
    (if (null value) 0 value)))

(defun get-at-index (index start program)
  (gethash (+ start index) program))

(defun get-nth (index mode relative start program)
  (get-value (get-at-index index start program) mode relative program))

(defun get-nth-write (index mode relative start program)
  (let ((pos (get-at-index index start program)))
    (cond
      ((= 0 mode) pos)
      ((= 2 mode) (+ pos relative))
      (t (error "mode not allowed for write parameter")))))

(defun do-three-argument (fn p1 p2 p3 relative start program)
  (let ((x (get-nth 1 p1 relative start program))
        (y (get-nth 2 p2 relative start program))
        (pos (get-nth-write 3 p3 relative start program)))
    (let ((value (funcall fn x y)))
      (sethash pos value program))))

(defun do-add (p1 p2 p3 relative start program)
  (do-three-argument #'+ p1 p2 p3 relative start program))

(defun do-multiply (p1 p2 p3 relative start program)
  (do-three-argument #'* p1 p2 p3 relative start program))

(defun do-input (input mode relative start program)
  (let ((x (get-nth-write 1 mode relative start program)))
    (if (null input) (error "nil input"))
    (sethash x input program)))

(defun do-output (p1 relative start program)
  (let ((value (get-nth 1 p1 relative start program)))
    value))

(defun do-jump-if-true (p1 p2 relative start program)
  (let ((x (get-nth 1 p1 relative start program)) (y (get-nth 2 p2 relative start program)))
    (if (/= 0 x)
        y
        (+ start 3))))

(defun do-jump-if-false (p1 p2 relative start program)
  (let ((x (get-nth 1 p1 relative start program)) (y (get-nth 2 p2 relative start program)))
    (if (= 0 x)
        y
        (+ start 3))))

(defun do-less-than (p1 p2 p3 relative start program)
  (let ((x (get-nth 1 p1 relative start program))
        (y (get-nth 2 p2 relative start program))
        (pos (get-nth-write 3 p3 relative start program)))
    (if (< x y)
        (sethash pos 1 program)
        (sethash pos 0 program))))

(defun do-equals (p1 p2 p3 relative start program)
  (let ((x (get-nth 1 p1 relative start program))
        (y (get-nth 2 p2 relative start program))
        (pos (get-nth-write 3 p3 relative start program)))
    (if (= x y)
        (sethash pos 1 program)
        (sethash pos 0 program))))

(defun do-relative (p1 relative start program)
  (let ((value (get-nth 1 p1 relative start program)))
    (+ relative value)))

(defun calculate (input start program relative output)
  (let ((command (gethash start program)))
    (multiple-value-bind (opcode p1 p2 p3) (decode-command command)
      (cond
        ((= opcode 99)
         (values 'done (list output start program relative)))
        ((= opcode 1)
         (do-add p1 p2 p3 relative start program)
         (calculate input (+ 4 start) program relative output))
        ((= opcode 2)
         (do-multiply p1 p2 p3 relative start program)
         (calculate input (+ 4 start) program relative output))
        ((= opcode 3)
         (if (null input)
             (values 'input (list output start program relative output))
             (progn
               (do-input (pop input) p1 relative start program)
               (calculate input (+ 2 start) program relative output))))
        ((= opcode 4)
         (let ((new-output (push (do-output p1 relative start program) output)))
           (calculate input (+ 2 start) program relative new-output)))
        ((= opcode 5)
         (calculate input (do-jump-if-true p1 p2 relative start program) program relative output))
        ((= opcode 6)
         (calculate input (do-jump-if-false p1 p2 relative start program) program relative output))
        ((= opcode 7)
         (do-less-than p1 p2 p3 relative start program)
         (calculate input (+ 4 start) program relative output))
        ((= opcode 8)
         (do-equals p1 p2 p3 relative start program)
         (calculate input (+ 4 start) program relative output))
        ((= opcode 9)
         (calculate input (+ 2 start) program (do-relative p1 relative start program) output))
        (t output)))))

(defun decode-command (command)
  (let* ((opcode (rem command 100))
         (p1 (rem (/ (- command opcode) 100) 10))
         (p2 (rem (/ (- command opcode (* 100 p1)) 1000) 10))
         (p3 (rem (/ (- command opcode (* 100 p1) (* 1000 p2)) 10000) 10)))
    (values opcode p1 p2 p3)))

(defun program-to-hash (list)
  (let ((i 0)
        (hash (newhash)))
    (dolist (k list)
      (sethash i k hash)
      (incf i))
    hash))

(defun list-to-hash (list)
  (let ((x 0)
        (y 0)
        (hash (newhash))
        (start (list 0 0)))
    (dolist (element list)
      (cond ((= element 10)
             (incf y)
             (setf x 0))
            ((or (= element 35)
                 (startp element))
             (sethash (list x y) element hash)
             (if (startp element)
                 (setf start (list x y)))
             (incf x))
            (t (incf x))))
    (values hash start)))

(defun startp (element)
  (or (= element (char-code #\<))
      (= element (char-code #\>))
      (= element (char-code #\^))
      (= element (char-code #\v))))

(defun count-intersections (hash)
  (let ((count 0))
    (maphash #'(lambda (pos v)
                 (declare (ignore v))
                 (let ((x (nth 0 pos))
                       (y (nth 1 pos)))
                   (setf count (+ count (intersection-value x y hash))))) hash)
    count))

(defun intersection-value (x y hash)
  (if (or (null (gethash (list (1+ x) y) hash))
          (null (gethash (list (1- x) y) hash))
          (null (gethash (list x (1+ y)) hash))
          (null (gethash (list x (1- y)) hash)))
      0
      (* x y)))

(defun print-labirynth (input)
  (map 'string #'code-char input))

(defun get-scaffold (input)
  (multiple-value-bind (type result) (calculate () 0 input 0 ())
    (declare (ignore type))
    (reverse (nth 0 result))))

(defun vectorize (input)
  (let ((vectors (list 'l)))
    (multiple-value-bind (hash start) (list-to-hash input)
      (do*
       ((starting start finish)
        (last-direction nil direction)
        (direction (next-direction starting '() hash)
                   (next-direction starting direction hash))
        (finish (find-last-point starting direction hash)
                (find-last-point starting direction hash)))
       ((donep direction) vectors)
        (if (not (null last-direction))
            (setf vectors (push (vectors-to-direction last-direction direction) vectors)))
        (setf vectors (push (vector-lenght (list starting finish)) vectors))))
    (reverse vectors)))

(defun donep (direction)
  (null direction))

(defun find-last-point (first direction hash)
  (do ((length 1 (1+ length)))
      ((null (gethash (move first (scale length direction)) hash))
       (move first (scale (1- length) direction)))))

(defun scale (length vector)
  (map 'list #'(lambda (x) (* x length)) vector))

(defun next-direction (from last-vector hash)
  (let ((new-vectors (remove (scale -1 last-vector) '((-1 0) (1 0) (0 -1) (0 1)) :test #'equal)))
    (dolist (new-vector new-vectors)
      (if (not (null (gethash (move from new-vector) hash))) (return new-vector)))))

(defun move (point vector)
  (mapcar #'+ point vector))

(defun vector-length (vector)
  (let ((start (nth 0 vector))
        (end (nth 1 vector)))
    (abs (reduce #'+ (mapcar #'- start end)))))

(defun vectors-to-direction (start turn)
  (let ((right-vectors '(((-1 0) (0 -1))
                         ((0 1) (-1 0))
                         ((0 -1) (1 0))
                         ((1 0) (0 1)))))
    (if (find (list start turn) right-vectors :test #'equal)
        'r
        'l)))

(defun program-robot (input)
  (let* ((main-program
          (concatenate 'list (program-to-list "A,B,A,C,B,C,A,C,B,C") '(10)))
         (routine-a
          (concatenate 'list (program-to-list "L,8,R,10,L,10") '(10)))
         (routine-b
          (concatenate 'list (program-to-list "R,10,L,8,L,8,L,10") '(10)))
         (routine-c
          (concatenate 'list (program-to-list "L,4,L,6,L,8,L,8") '(10)))
         (feed (concatenate 'list (program-to-list "n") '(10)))
         (whole-program (concatenate 'list main-program routine-a routine-b routine-c feed)))
    (sethash 0 2 input)
    (multiple-value-bind (type result) (calculate whole-program 0 input 0 ())
      (declare (ignore type))
      (car (car result)))))

(defun program-to-list (program)
  (map 'list #'char-code program))

;; day 17, part one
(time (assert (= 5940
                 (count-intersections
                  (list-to-hash (get-scaffold (program-to-hash (input))))))))

;; day 17, part two
(time (assert (= 923795 (program-robot (program-to-hash (input))))))
